package com.example.YuCeClient.util;import android.content.Context;import android.graphics.*;import android.graphics.Bitmap.Config;import android.graphics.BitmapFactory.Options;import android.graphics.drawable.Drawable;import android.net.Uri;import android.os.Build;import android.text.TextUtils;import android.util.TypedValue;import android.view.animation.Animation;import android.widget.ImageView;import com.example.YuCeClient.background.PathManager;import com.example.YuCeClient.background.config.MD5;import com.squareup.picasso.*;import com.squareup.picasso.Picasso.LoadedFrom;import java.io.*;import java.net.HttpURLConnection;import java.util.ArrayList;import java.util.List;/** *  * @title:Picasso 封装工具类 用户图片异步下载 * @description: * @company: 美丽说（北京）网络科技有限公司 * @author yinxinya * @version 1.0 * @created * @changeRecord */public class PicassoUtil {	private Picasso mPicassoExternal;	private Picasso mPicassoInternal;	private List<Target> mTargets = new ArrayList<Target>();	private boolean internalCache = false;	private Downloader mDownloaderExternal;	private Downloader mDownloaderInternal;	private Context mContext;	private static PicassoUtil mPicassoUtil;	private PicassoUtil(Context context) {		initContext(context);	}	public void initContext(Context context) {		if (context != null) {			mContext = context.getApplicationContext();		}	}	public static PicassoUtil getInstance(Context context) {		if (mPicassoUtil == null) {			mPicassoUtil = new PicassoUtil(context);		}		mPicassoUtil.initContext(context);		return mPicassoUtil;	}	private Picasso initPicasso() {		Picasso picasso = null;		if (internalCache) {			if (mPicassoInternal == null) {				String cacheDir = mContext.getCacheDir().getAbsolutePath();				// 默认使用http缓存（存在部分机型下载慢以及版本兼容性问题 4.0以上才支持）所以自定义downloader				mDownloaderInternal = new MlsConnectionDownloader(mContext,cacheDir);				mPicassoInternal = new Picasso.Builder(mContext).downloader(mDownloaderInternal).build();				mPicassoInternal.setDebugging(false);			}			picasso = mPicassoInternal;		} else {			if (mPicassoExternal == null) {				String cacheDir = PathManager.getImageLoaderCacheDir().getAbsolutePath();				// 默认使用http缓存（存在部分机型下载慢以及版本兼容性问题 4.0以上才支持）所以自定义downloader				mDownloaderExternal = new MlsConnectionDownloader(mContext,cacheDir);				mPicassoExternal = new Picasso.Builder(mContext).downloader(mDownloaderExternal).build();				mPicassoExternal.setDebugging(false);			}			picasso = mPicassoExternal;		}		internalCache = false;		return picasso;	}	/**	 * 下载到内部存储空间 /data/data/com.meilishuo/cache	 */	public void loadToInternal() {		internalCache = true;	}	/**	 * 下载图片 注意方法不是异步的	 * 	 * @param	 * @param url	 * @return	 */	public byte[] downPicBytes(String url, boolean localCacheOnly) {		if (TextUtils.isEmpty(url)) {			return null;		}		try {			InputStream inputStream = null;			if (internalCache) {				inputStream = mDownloaderInternal.load(Uri.parse(url),						localCacheOnly).getInputStream();			} else {				inputStream = mDownloaderExternal.load(Uri.parse(url),						localCacheOnly).getInputStream();			}			if (inputStream != null) {				ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();				byte[] buffer = new byte[1024 * 8];				int n = -1;				while (-1 != (n = inputStream.read(buffer))) {					byteArrayOutputStream.write(buffer, 0, n);				}				buffer = byteArrayOutputStream.toByteArray();				inputStream.close();				byteArrayOutputStream.close();				return buffer;			}		} catch (IOException e) {			e.printStackTrace();		} catch (Exception e) {			e.printStackTrace();		}		return null;	}	public static int[] sizeOfBitmap(byte[] data) {		Options options = new Options();		options.inJustDecodeBounds = true;		BitmapFactory.decodeByteArray(data, 0, data.length, options);		return new int[] { options.outWidth, options.outHeight };	}	public static int[] sizeOfBitmap(InputStream in) {		Options options = new Options();		options.inJustDecodeBounds = true;		BitmapFactory.decodeStream(in, null, options);		return new int[] { options.outWidth, options.outHeight };	}	public static int[] sizeOfBitmap(String path) {		InputStream in = null;		int[] size = new int[] { 0, 0 };		try {			in = new FileInputStream(path);			size = sizeOfBitmap(in);		} catch (FileNotFoundException e) {			e.printStackTrace();		} finally {			if (in != null) {				try {					in.close();				} catch (IOException e) {					e.printStackTrace();				}			}		}		return size;	}		public void downPic(String url, final ImageView imageView, Transformation transformation) {		if (TextUtils.isEmpty(url)) {			return;		}		RequestCreator requestCreator = buildRequestCreator(url, -1, -1,				transformation);		requestCreator.into(imageView);	}	public RequestCreator buildRequestCreator(String url, int placeholderResId,			int errorResId, Transformation transformation) {		File file = new File(url);		RequestCreator requestCreator = null;		if (file.exists()) {			requestCreator = initPicasso().load(file);		} else {			requestCreator = initPicasso().load(url);		}		requestCreator = requestCreator.noFade();		if (placeholderResId == -1) {			placeholderResId = android.R.color.transparent;		}		if (errorResId == -1) {			errorResId = android.R.color.transparent;		}		requestCreator = requestCreator.placeholder(placeholderResId);		requestCreator = requestCreator.error(errorResId);		if (transformation != null) {			requestCreator = requestCreator.transform(transformation);		}		return requestCreator;	}	public void downPic(String url, final ImageView imageView,			int placeholderResId, int errorResId,			Transformation transformation, final Animation animation) {		if (TextUtils.isEmpty(url)) {			return;		}		RequestCreator requestCreator = buildRequestCreator(url,				placeholderResId, errorResId, transformation);		if (animation == null) {			if (imageView != null) {				requestCreator.into(imageView);			}		} else {			requestCreator.into(imageView, new Callback() {				@Override				public void onSuccess() {					if (imageView != null) {						imageView.clearAnimation();						imageView.startAnimation(animation);					}				}				@Override				public void onError() {				}			});		}	}	public void downPic(String url, final ImageView imageView,			int placeholderResId, int errorResId, Callback callback) {		if (TextUtils.isEmpty(url)) {			return;		}		RequestCreator requestCreator = buildRequestCreator(url,				placeholderResId, errorResId, null);		requestCreator.into(imageView, callback);	}	public void downPic(String url, final ImageView imageView,			int placeholderResId, int errorResId) {		downPic(url, imageView, placeholderResId, errorResId, null, null);	}	// 下载图后回调	public void downPicCallback(String url, final ImageView imageView,			Callback callback) {		downPic(url, imageView, -1, -1, callback);	}	public void downPic(String url, final ImageView imageView) {		downPic(url, imageView, -1, -1, null, null);	}	public void downPic(String url, final Target target) {		downPic(url, null, target);	}	public void downPic(String url, Transformation transformation,			final Target target) {		if (TextUtils.isEmpty(url)) {			return;		}		RequestCreator requestCreator = buildRequestCreator(url, -1, -1,				transformation);		// 对target封装一层 解决弱引用回收回掉不到的问题		Target target2 = new Target() {			@Override			public void onPrepareLoad(Drawable placeHolderDrawable) {				if (target != null) {					target.onPrepareLoad(placeHolderDrawable);				}			}			@Override			public void onBitmapLoaded(Bitmap bitmap, LoadedFrom from) {				if (target != null) {					target.onBitmapLoaded(bitmap, from);				}				if (mTargets.contains(this)) {					mTargets.remove(this);				}			}			@Override			public void onBitmapFailed(Drawable errorDrawable) {				if (target != null) {					target.onBitmapFailed(errorDrawable);				}				if (mTargets.contains(this)) {					mTargets.remove(this);				}			}		};		if (!mTargets.contains(target2)) {			mTargets.add(target2);		}		requestCreator.into(target2);	}		/**	 * 获取圆形图片	 * @param bitmap	 * @return	 */	public Bitmap getRoundBitmap(Bitmap bitmap) {		if (bitmap != null) {			int w = bitmap.getWidth();			Bitmap b = Bitmap.createBitmap(w, w, Config.ARGB_8888);			Canvas canvas = new Canvas(b);			Paint paint = new Paint();			paint.setColor(Color.GRAY);			Rect rect = new Rect(0, 0, w, w);			RectF rectF = new RectF(rect);			paint.setAntiAlias(true);			canvas.drawARGB(0, 0, 0, 0);			canvas.drawCircle(w / 2.f, w / 2.f, w / 2.f, paint);			paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));			canvas.drawBitmap(bitmap, rect, rectF, paint);//			if (hasBorder) {//				canvas.drawCircle(w / 2.f, w / 2.f, (w - borderW) / 2.f,//						borderPaint);//			}			if (bitmap != null && !bitmap.isRecycled()) {				bitmap.recycle();				bitmap = null;			}			return b;		} else {			return null;		}	}		/**	 * 圆形处理	 * 	 * @param	 * @param	 * @return	 */	public Transformation getRoundTransformation() {		Transformation transformation = new Transformation() {			@Override			public Bitmap transform(Bitmap source) {				Bitmap bitmap = getRoundBitmap(source);				if (!source.isRecycled()) {					source.recycle();				}				return bitmap;			}			@Override			public String key() {				return "getRoundTransformation";			}		};		return transformation;	}	/**	 * 圆角处理	 * 	 * @param	 * @param clipBottom	 * @return	 */	public Transformation getRoundTransformation(final boolean clipBottom) {		Transformation transformation = new Transformation() {			@Override			public Bitmap transform(Bitmap source) {				Bitmap bitmap = getRoundBitmap(mContext, source, clipBottom);				if (!source.isRecycled()) {					source.recycle();				}				return bitmap;			}			@Override			public String key() {				return "getRoundTransformation";			}		};		return transformation;	}	/**	 * 调整大小&圆角处理	 * 	 * @param	 * @param width	 * @return	 */	public Transformation getRoundAndSizeTransformation(final int width) {		Transformation transformation = new Transformation() {			@Override			public Bitmap transform(Bitmap source) {				Bitmap bitmap = getRoundBitmap(mContext,						resizeBitmap(width, source), true);				if (!source.isRecycled()) {					source.recycle();				}				return bitmap;			}			@Override			public String key() {				return "getRoundAndSizeTransformation";			}		};		return transformation;	}	/**	 * 调整大小&圆角处理	 * 	 * @param	 * @param	 * @return	 */	public Transformation getRoundAndSizeTransformation(final int img_width,			final int img_height) {		Transformation transformation = new Transformation() {			@Override			public Bitmap transform(Bitmap bitmap) {				int width = img_width;				int height = img_height;				int w = bitmap.getWidth();				int h = bitmap.getHeight();				int bitW = 0, bitH = 0;				if (width != 0 && height != 0) {					if (1.0 * w * height / h - width > 0) {						// 宽大于高						width = width * h / height;						height = h;						bitW = (w - width) / 2;						bitH = 0;					} else {						height = height * w / width;						width = w;						bitW = 0;						bitH = (h - height) / 2;					}				} else {					width = w;					height = h;				}				try {					Bitmap b = Bitmap.createBitmap(width, height,							Config.ARGB_8888);					Canvas canvas = new Canvas(b);					Paint paint = new Paint();					paint.setColor(Color.GRAY);					Rect rect = new Rect(bitW, bitH, bitW + width, bitH							+ height);					RectF rectF = new RectF(0, 0, width, height);					paint.setAntiAlias(true);					int oneDip = DisplayUtil.dip2px(1, mContext.getResources()							.getDisplayMetrics().density);					int round = 6 * oneDip;					canvas.drawRoundRect(rectF, round, round, paint);					paint.setXfermode(new PorterDuffXfermode(							PorterDuff.Mode.SRC_IN));					canvas.drawBitmap(bitmap, rect, rectF, paint);					if (bitmap != null && !bitmap.isRecycled()) {						bitmap.recycle();						bitmap = null;					}					return b;				} catch (Exception e) {				}				return null;			}			@Override			public String key() {				return "getRoundAndSizeTransformation";			}		};		return transformation;	}	/**	 * 获取圆角图片	 * 	 * @param context	 * @param bitmap	 * @param clipBottom	 *            图片下边缘是否进行圆角处理	 * @return	 */	public Bitmap getRoundBitmap(Context context, Bitmap bitmap,			boolean clipBottom) {		int w = bitmap.getWidth();		int h = bitmap.getHeight();		try {			Bitmap b = Bitmap.createBitmap(w, h, Config.ARGB_8888);			Canvas canvas = new Canvas(b);			Paint paint = new Paint();			paint.setColor(Color.GRAY);			Rect rect = new Rect(0, 0, w, h);			RectF rectF = new RectF(rect);			paint.setAntiAlias(true);			float r = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,					4.5f, context.getResources().getDisplayMetrics());			canvas.drawRoundRect(rectF, r, r, paint);			if (!clipBottom) {				canvas.drawRect(new Rect(0, h - 15, w, h), paint);			}			paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));			canvas.drawBitmap(bitmap, rect, rectF, paint);			if (bitmap != null && !bitmap.isRecycled()) {				bitmap.recycle();				bitmap = null;			}			return b;		} catch (Exception e) {		} catch (OutOfMemoryError error) {		}		return null;	}	/**	 * 调整图片尺寸	 * 	 * @param width	 * @param bmp	 * @return	 */	public Bitmap resizeBitmap(int width, Bitmap bmp) {		if (bmp != null && bmp.getWidth() > 0) {			Matrix matrix = new Matrix();			float scale = width * 1.0f / bmp.getWidth();			matrix.postScale(scale, scale);			Bitmap bitmap = Bitmap.createBitmap(bmp, 0, 0, bmp.getWidth(),					bmp.getHeight(), matrix, true);			if (!bmp.isRecycled()) {				bmp.recycle();			}			return bitmap;		}		return null;	}}/** *  * @title:Picasso自定义下载管理器 负责磁盘缓存管理 * @description: * @company: 美丽说（北京）网络科技有限公司 * @author yinxinya * @version 1.0 * @created * @changeRecord */class MlsConnectionDownloader extends UrlConnectionDownloader {	public String mCacheDir;	public MlsConnectionDownloader(Context context, String cacheDir) {		super(context);		mCacheDir = cacheDir;		disableConnectionReuseIfNecessary();	}	private void disableConnectionReuseIfNecessary() {		// Work around pre-Froyo bugs in HTTP connection reuse.		if (Build.VERSION.SDK_INT < 8) {			System.setProperty("http.keepAlive", "false");		}	}	/**	 * 尝试从从磁盘载入图片	 * 	 * @param uri	 * @param	 * @return	 */	private Response loadFromDisk(Uri uri) {		if (TextUtils.isEmpty(mCacheDir)) {			return null;		}		File dir = new File(mCacheDir);		if (dir != null) {			dir.mkdirs();		}		if (!dir.exists()) {			return null;		}		String fileName = MD5.toMd5(uri.toString());		File file = new File(dir, fileName);		if (file.exists()) {			try {				FileInputStream fileInputStream = new FileInputStream(file);				return new Response(fileInputStream, true);			} catch (FileNotFoundException e) {				e.printStackTrace();			}		}		return null;	}	/**	 * 缓存图片到磁盘	 * 	 * @param uri	 * @param bytes	 */	private void writeToDisk(final Uri uri, final byte[] bytes) {		if (TextUtils.isEmpty(mCacheDir)) {			return;		}		File dir = new File(mCacheDir);		if (dir != null) {			dir.mkdirs();		}		if (!dir.exists()) {			return;		}		String fileName = MD5.toMd5(uri.toString());		String tmpName = fileName + ".tmp";		File file = new File(dir, tmpName);		if (!file.exists()) {			boolean success = false;			try {				FileOutputStream fileOutputStream = new FileOutputStream(file);				fileOutputStream.write(bytes);				fileOutputStream.flush();				if (fileOutputStream != null) {					fileOutputStream.close();				}				file.renameTo(new File(dir, fileName));				success = true;			} catch (FileNotFoundException e) {				e.printStackTrace();			} catch (IOException e) {				e.printStackTrace();			} finally {				if (!success && file.exists()) {					file.delete();				}			}		}	}	@Override	public Response load(Uri uri, boolean localCacheOnly) throws IOException {		Response response = loadFromDisk(uri);		if (response != null) {			return response;		}		if (localCacheOnly) {			return null;		}		HttpURLConnection connection = openConnection(uri);		int responseCode = connection.getResponseCode();		if (responseCode >= 300) {			connection.disconnect();			return null;		}		InputStream inputStream = connection.getInputStream();		ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();		byte[] buffer = new byte[1024 * 8];		int n = -1;		while (-1 != (n = inputStream.read(buffer))) {			byteArrayOutputStream.write(buffer, 0, n);		}		byte[] bytes = byteArrayOutputStream.toByteArray();		byteArrayOutputStream.close();		inputStream.close();		connection.disconnect();		writeToDisk(uri, bytes);		ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(				bytes);		return new Response(byteArrayInputStream, false);	}}